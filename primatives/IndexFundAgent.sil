pragma silverscript ^0.1.0;

// IndexFundAgent v2 â€” Expanded Basket for AFA v0.2 (Entangled + Hedger ready)
contract IndexFundAgent(
    array<bytes> componentBytecodes,   // up to 8 targets
    array<int> weightsBasisPoints,     // must sum to 10000
    pubkey feeBeneficiary,
    int feeBasisPointsPerRebalance,
    int rebalanceDelaySeconds,
    int minOperationSompi
) {
    // Constructor validation
    require(componentBytecodes.length == weightsBasisPoints.length);
    require(componentBytecodes.length >= 2 && componentBytecodes.length <= 8);

    int totalWeight = 0;
    for(i, 0, weightsBasisPoints.length) {
        totalWeight = totalWeight + weightsBasisPoints[i];
    }
    require(totalWeight == 10000);

    // Helper: total input value
    function int getTotalInput() -> int {
        int total = 0;
        for(i, 0, tx.inputs.length) {
            total = total + tx.inputs[i].value;
        }
        return total;
    }

    // Proportional withdrawal (redeem)
    entrypoint function redeem(pubkey userBeneficiary) {
        int totalInput = getTotalInput();
        int redeemAmount = tx.outputs[0].value;

        require(redeemAmount >= minOperationSompi);
        require(redeemAmount <= totalInput - minOperationSompi - 4000);

        bytes34 userLock = new LockingBytecodeP2PK(userBeneficiary);
        require(tx.outputs[0].lockingBytecode == userLock);

        int remainder = totalInput - redeemAmount - 4000;
        require(remainder >= minOperationSompi);
        require(tx.outputs[1].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
        require(tx.outputs[1].value == remainder);
    }

    // Core rebalance (anyone can call after delay)
    entrypoint function rebalance() {
        require(this.age >= rebalanceDelaySeconds);

        int totalInput = getTotalInput();
        int feeAmount = 0;
        if (feeBasisPointsPerRebalance > 0 && feeBeneficiary != empty) {
            feeAmount = (totalInput * feeBasisPointsPerRebalance) / 10000;
            require(feeAmount >= minOperationSompi);
        }

        int allocatable = totalInput - feeAmount - 6000;
        require(allocatable > 0);

        int outputIndex = 0;

        // Fee drip
        if (feeAmount > 0) {
            bytes34 feeLock = new LockingBytecodeP2PK(feeBeneficiary);
            require(tx.outputs[outputIndex].lockingBytecode == feeLock);
            require(tx.outputs[outputIndex].value == feeAmount);
            outputIndex = outputIndex + 1;
        }

        // Proportional splits
        int accumulated = 0;
        for(i, 0, componentBytecodes.length) {
            bytes target = componentBytecodes[i];
            int weight = weightsBasisPoints[i];

            int amount = (allocatable * weight) / 10000;
            if (i == componentBytecodes.length - 1) {
                amount = allocatable - accumulated;
            }
            accumulated = accumulated + amount;

            require(amount >= minOperationSompi);
            require(tx.outputs[outputIndex].lockingBytecode == target);
            require(tx.outputs[outputIndex].value == amount);

            outputIndex = outputIndex + 1;
        }
    }
}
